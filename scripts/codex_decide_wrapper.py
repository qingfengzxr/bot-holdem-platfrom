#!/usr/bin/env python3
"""
Normalize codex CLI output into strict JSON action decision for single_seat_client.

Input (stdin): JSON generated by headless-agent-client policy adapter.
Output (stdout): strict JSON:
  {"action_type":"fold|check|call|raise_to|all_in","amount":null|"123","rationale":"..."}
"""

from __future__ import annotations

import json
import os
import re
import shlex
import subprocess
import sys
from typing import Any, Dict, List, Optional


def _extract_json_object(text: str) -> Optional[Dict[str, Any]]:
    # Try direct parse first.
    try:
        val = json.loads(text)
        if isinstance(val, dict):
            return val
    except Exception:
        pass

    # Fallback: parse the first {...} block.
    match = re.search(r"\{[\s\S]*\}", text)
    if not match:
        return None
    try:
        val = json.loads(match.group(0))
        if isinstance(val, dict):
            return val
    except Exception:
        return None
    return None


def _choose_fallback_action(legal: List[str]) -> str:
    legal_l = [x.strip().lower() for x in legal]
    for preferred in ("check", "call", "fold"):
        if preferred in legal_l:
            return preferred
    return legal_l[0] if legal_l else "fold"


def _normalize_decision(raw: Dict[str, Any], legal: List[str]) -> Dict[str, Any]:
    allowed = {"fold", "check", "call", "raise_to", "all_in"}
    action = str(raw.get("action_type", "")).strip().lower()
    if action not in allowed or action not in set(map(str.lower, legal)):
        action = _choose_fallback_action(legal)

    amount = raw.get("amount")
    amount_norm: Optional[str]
    if amount is None or amount == "":
        amount_norm = None
    else:
        amount_norm = str(amount)
        if not amount_norm.isdigit():
            amount_norm = None

    rationale = raw.get("rationale")
    if not isinstance(rationale, str) or not rationale.strip():
        rationale = "codex_wrapper_normalized"

    return {
        "action_type": action,
        "amount": amount_norm,
        "rationale": rationale,
    }


def _build_codex_prompt(payload: Dict[str, Any]) -> str:
    return json.dumps(
        {
            "task": "poker_action_decision",
            "instruction": (
                "Return ONLY JSON with fields action_type, amount, rationale. "
                "action_type must be one of legal_actions. "
                "If private_state_json.decrypted_hole_cards_pretty exists, use it as canonical cards "
                "(e.g. As, Td). If only private_state_json.decrypted_hole_cards exists, decode using "
                "private_state_json.card_index_encoding. Use public_state_json.board_cards_pretty "
                "as the canonical public board cards when present."
            ),
            "input": payload.get("input", payload),
        },
        ensure_ascii=False,
    )


def main() -> int:
    raw_stdin = sys.stdin.read()
    payload = _extract_json_object(raw_stdin)
    if payload is None:
        out = {
            "action_type": "fold",
            "amount": None,
            "rationale": "wrapper_invalid_input",
        }
        print(json.dumps(out, ensure_ascii=False))
        return 0

    input_obj = payload.get("input", {})
    legal_actions = input_obj.get("legal_actions", [])
    if not isinstance(legal_actions, list):
        legal_actions = []
    legal_actions = [str(x) for x in legal_actions]

    codex_cmd = os.environ.get("CODEX_WRAPPER_CMD", "codex")
    codex_args = shlex.split(os.environ.get("CODEX_WRAPPER_ARGS", ""))
    if codex_cmd == "codex" and not codex_args:
        # Non-interactive mode is required for wrapper subprocess usage.
        codex_args = ["exec"]
    timeout_ms = int(os.environ.get("CODEX_WRAPPER_TIMEOUT_MS", "180000"))
    debug = os.environ.get("CODEX_WRAPPER_DEBUG", "").strip().lower() in {
        "1",
        "true",
        "yes",
        "on",
    }

    prompt = _build_codex_prompt(payload)
    decision_raw: Optional[Dict[str, Any]] = None
    try:
        proc = subprocess.run(
            [codex_cmd, *codex_args],
            input=prompt,
            text=True,
            capture_output=True,
            timeout=max(timeout_ms, 100) / 1000.0,
            check=False,
        )
        if debug:
            print(
                json.dumps(
                    {
                        "wrapper_debug": {
                            "cmd": [codex_cmd, *codex_args],
                            "returncode": proc.returncode,
                            "stdout_preview": proc.stdout[:500],
                            "stderr_preview": proc.stderr[:500],
                        }
                    },
                    ensure_ascii=False,
                ),
                file=sys.stderr,
            )
        decision_raw = _extract_json_object(proc.stdout.strip())
    except Exception:
        if debug:
            print(
                json.dumps(
                    {
                        "wrapper_debug": {
                            "cmd": [codex_cmd, *codex_args],
                            "exception": "subprocess_run_failed",
                        }
                    },
                    ensure_ascii=False,
                ),
                file=sys.stderr,
            )
        decision_raw = None

    if decision_raw is None:
        decision_raw = {
            "action_type": _choose_fallback_action(legal_actions),
            "amount": None,
            "rationale": "wrapper_fallback_rule",
        }

    out = _normalize_decision(decision_raw, legal_actions)
    print(json.dumps(out, ensure_ascii=False))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
